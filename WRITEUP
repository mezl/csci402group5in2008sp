Ttitle: Writeup for Project 2, Spring 2008

Date: 03/02/08

Group Num 05:	Chin-Kai Chang		chinkaic@usc.edu	7557011081
		Yang-Hsuen Liu		yanghsul@usc.edu	2925356804
		Cheng-Yu Lee		chengyul@usc.edu	9027332848

********************
* I. Requirements: *
********************
====================================================== PART 1 ======================================================
	- Implement the Lock Syscalls, Condition Syscalls, Exit Syscall, Yield Syscall, and Process Table.
	- Need to "bullet-proof" the Nachos kernel from user program errors.
	- Require a test suite of user programs that demonstrate the correctness of your system calls.
	- Demonstrate system calls work when used correctly and show it does not crash Nachos when used incorrectly.

	+ Lock Syscalls:
		- LOCK is not allowed to be acquired by Thread if other thread already acquired. 
		- Thread can not acquire the same LOCK which it already acquired.
		- Acquire and Release functions must be atomic.
		- Thread must wake up the waiting thread if current thread releases the LOCK.
		- If thread already acquired one LOCK, no second LOCK allow to acquire.
		- Thread can not release a LOCK if it doesn't have the LOCK.
		- CreateLock should return an integer value which is an index position into a kernel structure array of actual Lock. 
		- DestroyLock takes a single integer parameter as identifier for the Lock kernel object that is to be deleted.

	+ Condition Syscalls:
		- Wait, Signal, and Broadcast functions can be called by Thread with LOCK only.
		- Wait, Signal, and Broadcast functions must be atomic.
		- Sleep function can be called by Thread without LOCK only.
		- Signal function wake up next thread.
		- Broadcast function wake up waiting threads.
		- CreateCondition should return an integer value which is an index position into a kernel structure array of actual Condition. 
		- DestroyCondition takes a single integer parameter as identifier for the Condition kernel object that is to be deleted.

	+ Exit Syscalls
		- Ensure that Thread::Finish is called except for the very last thread running in Nachos.
		- Call interrupt->Halt() to actually stop Nachos for the last thread.

	+ Exec Syscalls
		- Create a new addresss space with the provided filename
		- Start a new thread in the address space and that will run the code

	+ Fork Syscalls
		- Create a new thread in the same address space.
		- Allocate new stack in the address space for the new thread to work with.
		
	+ Yield Syscalls
		- Call Thread::Yield() to give up or sleep.

	+ Process Table
		- Ensure to delete the address space and release any main memory for that thread's stack when exiting a thread.

====================================================== PART 2 ======================================================
	- Complete the implementation of the Exec and Fork system calls.
	- Keep track of allocating physical memory frames using a bitmap.
	- Copying data to/from the kernel from/to the user's virtual address space.
	- Allocate the new stack memory for the Fork. It will create the new pageTable which is larger than old pageTable and then copy the old pageTable data to the new pageTable.
	- Design a test suite that shows Exec and Fork perform correctly and show Nachos does not terminate abnormally when improper input is captured.

====================================================== PART 3 ======================================================
	- To create a scenario of customers applying passport at United States Passport Office.
	- To have multiple Passport Office running independently and executing by different processes simultaneously.
	- Implement this scenario as a set of multithreaded Nachos user programs with new Lock and Condition system calls in Part 1.
	- Require to use the Fork system call to create all threads in the program.
	- Implement a test suite that proves your implementation is correct.

	+ CUSTOMERS:
		- Upon entering Passport Office, Customers have choices of entering Application Clerk line or Picture Clerk line.
		
		- The chance of choosing Applicatiion Line before Picture Line is 50%
		- Upon entering the line, Customers have choice of preferred line or regular line in front of each Clerk.
		
		- The Customer will determine which line has fewer waiting customer to enter the faster line.
		- Customer have 25% chance of not liking their picture.
		- After complete the picture and application, Customers must line up at the Passport Clerk line.
		- After complete the passport line, Customers must line up at the Cashier Clerk line.
		- Leave the Passport Office and remember the type and order of the line they were located in when the Senator show up.
		- Only being serviced Customer can stay in the Passport Office until they are handled.
		- Back to the line they were in the Passport Office only if senator leave, in the exact order when they left.
		- Leaves the Passport Office after obtaining the passport.

	+ APPLICATION CLERKS:
		- Record that Customer has a completed application.
		- Money received by Application Clerk must be added up to received amount.
		- Go on break if no Customer on the line.

	+ PICTURE CLERKS:
		- Shown Customer's picture to Customer, once Customer accept the picture, official picture filed by Picture Clerk.
		
		- If the customer is not satisfied with the picture, the clerk retake the customer's picture
		- Money received by Picture Clerk must be added up to received amount.
		- Go on break if no Customer on the line.

	+ PASSPORT CLERKS:
		- Checks that a Customer has filed their completed application and has an official picture taken.
		- Money received by Passport Clerk must be added up to received amount.
		- Go on break if no Customer on the line.

	+ CASHIER CLERKS:
		- Take $100 passport fee from Customer if customer's passport has been filed.
		
		- If the customer's passport has not been filed upon the time the customer has been called by the cashier clerk,
		
		- the customer gets punshed by being forced to wait for a peirod of time (yield)
		
		- the customer goes to the back of the cashier line after being punished to wait for a period of time.
		- Money received by Cashier Clerk must be added up to received amount.
		- provide completed passport to Customer after Customer paid and record it.
		- Go on break if no Customer on the line.

	+ MANAGER:
		- The manager constantly monitor the number of clerk and customer in the office for a defined regular interval.
		- Wake up Clerks when there are no clerks at a specific table while having customer waiting in the line.		
		
		- Wake up Clerks when more than three Customers get in any particular line.		
		- Keep track of how much money the office has made. 
		- Print the total received from each Clerk type and a total from all Clerks.

	+ SENATOR:
		- Gets to go to each Clerk type and get their passport.
		- Wait until all Customers currently being serviced are handled.

********************
* II. Assumptions: *
********************
====================================================== PART 1 ======================================================
	- Nachos pages and memory size are 512 bytes. User Stack Size is by default.

====================================================== PART 2 ======================================================
	- Nachos pages and memory size are 512 bytes. User Stack Size is by default.

====================================================== PART 3 ======================================================
	- All customers are given $600 to help reduce the time required to get their passport completed.
	- The application is assumed to be passed, it is not explicitly provided in the shared data between the 2 threads.
	- Customers have 25% chance of not liking their picture.
	
	- Customers have 50% chance of entering application line before picture line, and vice vesa.
	
	- Customers acknowledge the sequence of tasks to be completed upon entering the office.

****************
* III. Design: *
****************
====================================================== PART 1 ======================================================
	+ exception.cc
		- int CreateLock_Syscall()
			- Create a new LOCK
			- Get index of the new LOCK
			- If failure to creat a LOCK, print failure message.

		- void DestroyLock_Syscall(int id)
			- Delete  index of a existing LOCK.
			- If failure to delete a LOCK, print failure message.

		- void Acquire_Syscall(int id)
			- Acquire index of a LOCK.
			- If failure to acquire a LOCK, print failure message.

		- void Release_Syscall(int id)
			- Release index of a LOCK.
			- If failure to release a LOCK, print failure message.

		- int CreateCondition_Syscall()
			- Create a condition of index.
			- If index is less than zero, print failure message.

		- void DestroyCondition_Syscall(int id)
			- Destroy the condition call.
			- If failure to destroy the condition, print failure message.
	
		- void Signal_Syscall(int conditionID, int lockID)
			- Signaling index of the LOCK.
			- If condition does not exist, print failure message.
			- If LOCK does not exist, print failure message.

		- void Wait_Syscall(int conditionID, int lockID)
			- Waiting index of the LOCK.
			- If condition does not exist, print failure message.
			- If LOCK does not exist, print failure message.

		- void Broadcast_Syscall(int conditionID, int lockID)
			- Broadcasting index of the LOCK.
			- If condition does not exist, print failure message.
			- If LOCK does not exist, print failure message.

====================================================== PART 2 ======================================================
	+ exception.cc	
		- void exec_thread()
			- Assign currentThread to initial register.
			- Assign currentThread to restore state.
	
		- SpaceId Exec_Syscall(char* name)
			- Open the virtual address and convert to physical address from register.
			- Create a new Kernel Thread and insert thread space or address space to the Process Table.
			- Kernel forks the exec_thread and return space id.

		- void kernel_thread(int virtualaddress)
			- Write PC register to virtual address.
			- write Next PC register to myIncrementPC.
			- Write Stack register to new stack.

		- void Fork_Syscall(int virtualaddress)
			- Create a new kernel Thread with process's name and address space and insert the Thread to Process Table.
			- Kernel forks the thread with virtual address.
		
		- void Yield_Syscall()
			- If Yield Syscall is called, put currentThread into sleep.

		- void Exit_Syscall(int status)
			- If Process Table has thread in the process, put currentThread into sleep.
			- If there are more than one thread in remove thread of Process Table, delete thread's address space.
			- If there is only one thread in the remove thread of Process Table, delete address space and interrupt using Halt().

	+ addrspace.cc
		- ProcessTable::ProcessTable()
			- Create a new Lock in Process Table.

		- ProcessTable::~ProcessTable()
			- Delete the lock in Process Table.
			- Allow hashmap begin to run and clear when finished.

		- int ProcessTable::AddThread(Thread* myThread)
			- Add a new thread in the Process Table.

		- int ProcessTable::RemoveThread(Thread* myThread)
			- Removing an existing thread in the Process Table.
			- Check the existence of thread in Process Table.
				-If not found or empty, removed thread success.

		- int ProcessTable::CheckChildExist(int mySpaceId)
			- Check the existence of current thread's space id.
			

	+ test_code.cc
		- void myCustomerForkFunc(int x)
			- To create a new customer thread in order to run.

		- void myClerkForkFunc(int x)
			- To create a new clerk thread in order to run.

====================================================== PART 3 ======================================================
	+ project2_final.c
		- void customerRun()
			- Get the Customer's ID and start running.
			- Customer go to Application Line.
			- Check the length of Prefer Line and Regular Line.
				- If Prefer Line is shorter than Regular Line or both line are empty.
					- Add Customer into Prefer Line. $500 will remove from Customer. Add one to Prefer Line count.
				- If Regular Line is shorter than Prefer Line.
					- Add Customer into Regular Line. Add one to Regular Line count.
			- Print message when Customer complete the Application Line.
			- Customer go to Picture Line.
			- Check the length of Prefer Line and Regular Line.
				- If Prefer Line is shorter than Regular Line or both line are empty.
					- Add Customer into Prefer Line. $500 will remove from Customer. Add one to Prefer Line count.
				- If Regular Line is shorter than Prefer Line.
					- Add Customer into Regular Line. Add one to Regular Line count.
			- Print message when Customer complete the Picture Line.
			
			- If Customer done with their picture and application, customer go to Passport Line.
			- Check the length of Prefer Line and Regular Line.
				- If Prefer Line is shorter than Regular Line or both line are empty.
					- Add Customer into Prefer Line. $500 will remove from Customer. Add one to Prefer Line count.
				- If Regular Line is shorter than Prefer Line.
					- Add Customer into Regular Line. Add one to Regular Line count.
			- Print message when Customer complete the Passport Line.
			- Customer go to Cashier Line.
			- Check the length of Prefer Line and Regular Line.
				- If Prefer Line is shorter than Regular Line or both line are empty.
					- Add Customer into Prefer Line. $500 will remove from Customer. Add one to Prefer Line count.
				- If Regular Line is shorter than Prefer Line.
					- Add Customer into Regular Line. Add one to Regular Line count.
			- Print message when Customer complete the Cashier Line.
			- Print message when Custmeer complete everything.

		- void applicationClerkRun()
			- Get Application Clerk ID and start running.
			- Acquire Prefer Line's Lock.
			- Check either there is Customer in the Prefer Line and print message.
				- If there is Customer in the Prefer Line.
					- Signal and release Prefer Line's Lock and back to CPU queue.
				- If there is no Customer in the Prefer Line.
					- Release prefer Line's Lock and acquire Regular Line's Lock.
			- Check either there is Customer in the Regular Line.
				- If there is Customer in the Regular Line.
					- Signal and release Regular Line's Lock.
				- If there is no Customer in the Regular Line.
					- Acquire Table Lock and wait on Table Condition.
					- Release Table Lock and print message. 

		- void pictureClerkRun()
			- Get Picture Clerk ID and start running.
			- Acquire Prefer Line's Lock.
			- Check either there is Customer in the Prefer Line and print message.
				- If there is Customer in the Prefer Line.
					- Signal and release Prefer Line's Lock and back to CPU queue.
				- If there is no Customer in the Prefer Line.
					- Release prefer Line's Lock and acquire Regular Line's Lock.
			- Check either there is Customer in the Regular Line.
				- If there is Customer in the Regular Line.
					- Signal and release Regular Line's Lock.
				- If there is no Customer in the Regular Line.
					- Clerk go on break.
					- Acquire Table Lock and wait on Table Condition.
					- Release Table Lock and print message. 

		- void passportClerkRun()
			- Get Passport Clerk ID and start running.
			- Acquire Prefer Line's Lock.
			- Check either there is Customer in the Prefer Line and print message.
				- If there is Customer in the Prefer Line.
					- Signal and release Prefer Line's Lock and back to CPU queue.
				- If there is no Customer in the Prefer Line.
					- Release prefer Line's Lock and acquire Regular Line's Lock.
			- Check either there is Customer in the Regular Line.
				- If there is Customer in the Regular Line.
					- Signal and release Regular Line's Lock.
				- If there is no Customer in the Regular Line.
					- Clerk go on break.
					- Acquire Table Lock and wait on Table Condition.
					- Release Table Lock and print message. 

		- void cashierClerkRun()
			- Get Cashier Clerk ID and start running.
			- Acquire Prefer Line's Lock.
			- Check either there is Customer in the Prefer Line and print message.
				- If there is Customer in the Prefer Line.
					- Signal and release Prefer Line's Lock and back to CPU queue.
				- If there is no Customer in the Prefer Line.
					- Release prefer Line's Lock and acquire Regular Line's Lock.
			- Check either there is Customer in the Regular Line.
				- If there is Customer in the Regular Line.
					- Signal and release Regular Line's Lock.
				- If there is no Customer in the Regular Line.
					- Clerk go on break.
					- Acquire Table Lock and wait on Table Condition.
					- Release Table Lock and print message.
 
		- void managerRun()
			- Check total finish Customers and print total number of finish customers.
			- Check the numbers of Clerk in Application Line.
				- If there is no Clerk in the line.
					- Manager wake up one Application Clerk.
			- Check the numbers of Clerk in Picture Line.
				- If there is no Clerk in the line.
					- Manager wake up one Picture Clerk.
			- Check the numbers of Clerk in Passport Line.
				- If there is no Clerk in the line.
					- Manager wake up one Passport Clerk.
			- Check the numbers of Clerk in Cashier Line.
				- If there is no Clerk in the line.
					- Manager wake up one Cashier Clerk.

		- void Initialize()
			- Create all required lock and condition for table, and line for passport office.
			- Initialize Clerk count equal zero for Application, Picture, Passport, and Cashier Clerk.
			- Initialize values for the four lines.
			- Create Customers give with $1,600 and no customer has been done in the beginning.
			- Creating Clerks for Application, Picture, Passport, and Cashier table.
			- Create manager.

		- void handleCustomer(int c,int type)
			- Type 0 : Application Clerk.
			- Type 1 : Picture Clerk.
			- Type 2 : Clerk.
			- Type 3 : Application Clerk.

		- int getCustomerID(int l,int PreOrReg)
			- Return the Customer ID to Clerk.
			- Check the Prefer Line and return Customer ID if existed.
			- Check the Regular Line and return Customer ID if existed.

***********************
* IV. Implementation: *
***********************
====================================================== PART 1 ======================================================
	+ Files Modified
		- exception.cc, system.cc, syscall.h, system.h, start.s.

	+ Files added
		- None.

	+ Data Structures added, and the file they were added to.
		+ system.h
			- extern Table lockTable.
			- extern Table conditionTable.

		+ system.cc
			- extern void Cleanup().

	+ Data Structures modified, and the file they were added to.
		- None.

	+ Functions added and in which file.
		+ exception.cc
			- int CreateLock_Syscall(){
				// create a new lock
				Lock* myLock = new Lock("New Lock");
	
				// get index of the new lock
				int id;
				id = lockTable.Put(myLock);

				// failure creating a lock
				if(id < 0){
					delete myLock;
					printf("Failure creating a lock of index %d \n", id);
				}

				// return lock index
				return id;
			  }

			- void DestroyLock_Syscall(int id){
				if(processTable.CheckChildExist(currentThread->space->getSpaceID()) == 1){
					Lock* myLock = (Lock*)lockTable.Remove(id);
					if(myLock == NULL){
						printf("Failure deleting a lock of index %d \n", id);
						return;
					}
					delete myLock;
				}
				else
					printf("Unable to destroy Lock because not last child thread \n");	
			  }

			- void Acquire_Syscall(int id){
				Lock* myLock = (Lock*)lockTable.Get(id);

				if(myLock == NULL){
					printf("Failure Acquiring a lock of index %d \n", id);
					return;
				}
				else{
					myLock -> Acquire();
				}
			  }

			- void Release_Syscall(int id){
				Lock* myLock = (Lock*)lockTable.Get(id);

				if(myLock == NULL){
					printf("Failure Releasing a lock of index %d \n", id);
					return;
				}
				else{
					myLock -> Release();
				}
			  }

			- int CreateCondition_Syscall(){
				Condition* myCondition = new Condition("New Condition");
				int id = conditionTable.Put(myCondition);

				if(id < 0){
					printf("Failure creating a condition of index %d \n", id);
					delete myCondition;
				}
				return id;
			  }

			- void DestroyCondition_Syscall(int id){	
				if(processTable.CheckChildExist(currentThread->space->getSpaceID()) == 1){
					Condition* myCondition = (Condition*)conditionTable.Remove(id);
					
					if(myCondition == NULL){	
						printf("Failure destroying a condition of index %d \n", id);
						return;
					}	
					delete myCondition;
				}
				else
					printf("Unable to destroy Condition because not last child thread \n");
	
			   }

			- void Signal_Syscall(int lockID, int conditionID){
				Condition* myCondition = (Condition*)conditionTable.Get(conditionID);
				Lock* myLock = (Lock*)lockTable.Get(lockID);

				if(myCondition == NULL){
					printf("Failure Signaling a condition (condition %d dont exist)", conditionID);
					return;
				}	
				if(myLock == NULL){
					printf("Failure Signaling a condition (lock %d dont exist)", lockID);	
					return;
				}
	
				myCondition -> Signal(myLock);
			  }

			- void Wait_Syscall(int lockID, int conditionID){
				Condition* myCondition = (Condition*)conditionTable.Get(conditionID);
				Lock* myLock = (Lock*)lockTable.Get(lockID);

				if(myCondition == NULL){
					printf("Failure waiting a condition (condition %d dont exist)", conditionID);
					return;
				}	
				if(myLock == NULL){
					printf("Failure waiting a condition (lock %d dont exist)", lockID);	
					return;
				}
	
				myCondition -> Wait(myLock);
			  }

			- void Broadcast_Syscall(int lockID, int conditionID){
				Condition* myCondition = (Condition*)conditionTable.Get(conditionID);
				Lock* myLock = (Lock*)lockTable.Get(lockID);

				if(myCondition == NULL){
					printf("Failure broadcasting a condition (condition %d dont exist)", conditionID);
					return;
				}	
				if(myLock == NULL){
					printf("Failure broadcasting a condition (lock %d dont exist)", lockID);	
					return;
				}
	
				myCondition -> Broadcast(myLock);
			  }


	+ Functions modified and in which file.
		- None.

====================================================== PART 2 ======================================================
	+ Files Modified
		- addrspace.cc, addrspace.h, system.cc, system.h, syscall.h, exception.cc, processTable.h, progtest.cc

	+ Files added
		- None.

	+ Data Structures added, and the file they were added to.
		+ system.h
			- extern ProcessTable processTable.
			- extern Table memoryTable.

	+ Data Structures modified, and the file they were added to.
		- None.

	+ Functions added and in which file.
		+ exception.cc
			- void exec_thread(){
				currentThread->space->InitRegisters();
				currentThread->space->RestoreState();
				machine->Run();
			  }

			- SpaceId Exec_Syscall(char* name){
				OpenFile* myFile = fileSystem->Open(name);
				AddrSpace* mySpace = new AddrSpace(myFile);
				Thread* myThread = new Thread(name);
				myThread->space = mySpace;
				int mySpaceId = myThread->space->getSpaceID();
				int myThreadId = processTable.AddThread(myThread);
	
				machine -> WriteRegister(2, mySpaceId);
				myThread->Fork((VoidFunctionPtr)exec_thread, 0);
				return mySpaceId;
			  }

			- void kernel_thread(int twoValues){
				int* twoValues_temp = (int*) twoValues;
				int virtualaddress = twoValues_temp[0];
				int stackAddress = twoValues_temp[1];

				int myIncrementPC = virtualaddress + 4;

				machine -> WriteRegister(PCReg, virtualaddress);	
				machine -> WriteRegister(NextPCReg, myIncrementPC);
				currentThread -> space -> RestoreState();
				machine -> WriteRegister(StackReg, stackAddress);
				machine -> Run();
			  }

			- void Fork_Syscall(int virtualaddress){
				Thread* myThread = new Thread(currentThread->getName());
				int* twoValues = new int[2];
				twoValues[0] = virtualaddress;

				int stackAddress = currentThread->space->newStack();
				myThread->space = currentThread->space;
				int mySpaceId = processTable.AddThread(myThread);

				if (stackAddress < 0){
					printf("Failure when allocating a new stack for fork");
					return;
				}
				twoValues[1] = stackAddress;
	
				myThread->Fork((VoidFunctionPtr)kernel_thread, (int)twoValues);
			  }


			- void Yield_Syscall(){	
				currentThread -> Yield();
			  }

			- void Exit_Syscall(int status){
				int check = processTable.RemoveThread(currentThread);
	
				if(check == -1){
					printf("Can't exit current thread\n");
				}
				if(check == 1 || check == 2)
					currentThread->space->~AddrSpace();

				if(check == 2)
					interrupt->Halt();

				if(status == 0)
					currentThread->Finish();
				else
					printf("Cannot exit current thread\n");
			  }

		+ addrspace.cc
			- ProcessTable::ProcessTable(){
				processTableLock = new Lock("Process Table Lock");
			  }

			- ProcessTable::~ProcessTable(){
				delete processTableLock;
				std::map<int, std::vector<Thread*> >::iterator iter;
				iter = hashmap.begin();
				while(!(iter == hashmap.end())){
					(iter->second).clear();
					iter++;
				}
				hashmap.clear();
			  }

			- int ProcessTable::AddThread(Thread* myThread){
				if(myThread == NULL){
					return -1;
				}

				processTableLock->Acquire();
				hashmap[myThread->space->getSpaceID()].push_back(myThread);
				processTableLock->Release();
				return myThread->space->getSpaceID();
			  }

			- int ProcessTable::RemoveThread(Thread* myThread){
				int removeSuccessful = -1;	

				if (myThread == NULL){
					printf("Failure removing non existance thread\n");
					removeSuccessful =  -1;
				}

				processTableLock->Acquire();
	
				int mySpaceId = myThread->space->getSpaceID();
				int targetThreadFound = 0;
				unsigned int i = 0;
				int found = 0;

				std::vector<Thread*>::iterator iter;
				iter = hashmap[mySpaceId].begin();
				while(i < hashmap[mySpaceId].size() ){
				if(myThread == (*iter)){
					found = 1;
					hashmap[mySpaceId].erase(iter);
					removeSuccessful = 0;
				}
				iter++;
				i++;
				if(i > hashmap[mySpaceId].size())
					break;
				}
	
				if(found == 0){
					printf("RemoveThread Failure: Thread doesn't exist in process table\n");
					removeSuccessful = -1;
				}


				if(hashmap[mySpaceId].empty()){
					hashmap.erase(mySpaceId);
					removeSuccessful = 1;
				}

				if(hashmap.empty() == TRUE)
					removeSuccessful = 2;

				processTableLock->Release();
				return removeSuccessful;
			  }


			- int ProcessTable::CheckChildExist(int mySpaceId){
				if(hashmap[mySpaceId].empty()){
					return 1;
				}
				return 0;
			  }
			
		+ test_code.cc
			- void myCustomerForkFunc(int x){
				Customer *c = (Customer*)x;
				printf("[custFork]Customer %d run\n",c->getID());
				c -> customerRun();
				delete c;
			  }

			- void myClerkForkFunc(int x){
				Clerk *cl = (Clerk*)x;
				printf("[ckerkFork]%s %d run\n",cl->getName(),cl->getID());
				cl -> run();
				delete cl;
			  }

	+ Functions modified and in which file.
		- None.

====================================================== PART 3 ======================================================
	+ Files Modified
		- None.

	+ Files added
		- project2_final.c

	+ Data Structures added, and the file they were added to.
		- None.

	+ Data Structures modified, and the file they were added to.
		- None.

	+ Functions added and in which file.
		- project2_final.c
			- void customerRun(){
				int myOwnID = -1;
				int i;
	
				/*get the customer ID*/
				Acquire(customerIDLock);
				myOwnID = customerIDCount;
				customerIDCount++;
				Release(customerIDLock);
				printf("[CUST] Customer %d start running \n", myOwnID);
	
	
				/* goto application line first*/
				printf("[CUST] Customer %d go queue up at applicaiton line \n", myOwnID);

				if(applicationLine.preferLineCount <= applicationLine.regLineCount){
					/* add itself to prefer line*/
					Acquire(applicationLine.preferLineLock);
					customerArray[myOwnID].money -= 500;
					applicationLine.money += 500;
					applicationLine.preferLineCount += 1;
					printf("[CUST] Customer %d have joined the app prefer Line \n", myOwnID);
					Wait(applicationLine.preferLineLock, applicationLine.preferLineCond);
					Release(applicationLine.preferLineLock);
				}
				else{
					/*add itself to regular line*/
					Acquire(applicationLine.regLineLock);
					applicationLine.regLineCount += 1;
					printf("[CUST] Customer %d have joined the app regular Line \n", myOwnID);
					Wait(applicationLine.regLineLock, applicationLine.regLineCond);
					Release(applicationLine.regLineLock);
				}
	
				/*application complete*/
				customerArray[myOwnID].applicationDone = 1;
				printf("[CUST] Customer %d have completed application", myOwnID);

				/*customer now goes to picture line*/
				printf("[CUST] Customer %d go queue up at picture line \n", myOwnID);

				if(pictureLine.preferLineCount <= pictureLine.regLineCount){
					/* add itself to prefer line*/
					Acquire(pictureLine.preferLineLock);
					customerArray[myOwnID].money -= 500;
					pictureLine.money += 500;
					pictureLine.preferLineCount += 1;
					printf("[CUST] Customer %d have joined the pic prefer Line \n", myOwnID);
					Wait(pictureLine.preferLineLock, pictureLine.preferLineCond);
					Release(pictureLine.preferLineLock);
				}
				else{
					/*add itself to regular line*/
					Acquire(pictureLine.regLineLock);
					pictureLine.regLineCount += 1;
					printf("[CUST] Customer %d have joined the pic regular Line \n", myOwnID);
					Wait(pictureLine.regLineLock, pictureLine.regLineCond);
					Release(pictureLine.regLineLock);
				}
	
				/*picture complete*/
				customerArray[myOwnID].pictureDone = 1;
				printf("[CUST] Customer %d have completed picture", myOwnID);
	
				while(customerArray[myOwnID].passportDone == 0){
					/*customer now goes to passport line*/
					printf("[CUST] Customer %d go queue up at passport line \n", myOwnID);

					if(passportLine.preferLineCount <= passportLine.regLineCount){
						/* add itself to prefer line*/
						Acquire(passportLine.preferLineLock);
						customerArray[myOwnID].money -= 500;
						passportLine.money += 500;
						passportLine.preferLineCount += 1;
						printf("[CUST] Customer %d have joined the pass prefer Line \n", myOwnID);
						Wait(passportLine.preferLineLock, passportLine.preferLineCond);
						Release(passportLine.preferLineLock);
					}
					else{
						/*add itself to regular line*/
						Acquire(passportLine.regLineLock);
						passportLine.regLineCount += 1;
						printf("[CUST] Customer %d have joined the pass regular Line \n", myOwnID);
						Wait(passportLine.regLineLock, passportLine.regLineCond);
						Release(passportLine.regLineLock);
					}
		
					/*picture complete*/
					if(customerArray[myOwnID].applicationDone == 1 && customerArray[myOwnID].pictureDone == 1){
						customerArray[myOwnID].passportDone = 1;
						printf("[CUST] Customer %d have completed passport", myOwnID);
					}
				}
	
				/*customer now goes to cashier line*/
				printf("[CUST] Customer %d go queue up at cashier line \n", myOwnID);
		
				if(cashierLine.preferLineCount <= cashierLine.regLineCount){
					/* add itself to prefer line*/
					Acquire(cashierLine.preferLineLock);
					customerArray[myOwnID].money -= 500;
					cashierLine.money += 500;
					cashierLine.preferLineCount += 1;
					printf("[CUST] Customer %d have joined the cash prefer Line \n", myOwnID);
					Wait(cashierLine.preferLineLock, cashierLine.preferLineCond);
					Release(cashierLine.preferLineLock);
				}
				else{
					/*add itself to regular line*/
					Acquire(cashierLine.regLineLock);
					cashierLine.regLineCount += 1;
					printf("[CUST] Customer %d have joined the cash regular Line \n", myOwnID);
					Wait(cashierLine.regLineLock, cashierLine.regLineCond);
					Release(cashierLine.regLineLock);
				}
	
				/*cashier complete*/
				customerArray[myOwnID].cashierDone = 1;
   				Yield(); 
				//printf("[CUST] Customer %d done cashier\n", myOwnID);
  				 Acquire(totalFinishCustomerLock);
  				 totalFinishCustomer++;
  				 Release(totalFinishCustomerLock);
	
				printf("[CUST] Customer %d completed !\n", myOwnID);
				printf("[CUST] !!!!!!!!!!!!!!!!!!!!!!!\n" );
				Exit(0);
			  }

			- void applicationClerkRun(){
   				int clerkID = -1;
  				int c = 0;//customer
  				int type = 0;//App type = 0;
   				//Get Application Clerk ID
   				Acquire(applicationClerkLock);
   				clerkID = applicationClerkIDCount ++;
  			 	Release(applicationClerkLock);
   
				printf("[Clerk]AppClerk %d Start Running \n",clerkID);
   				while(1){
      					//Do Lock
     					Acquire(applicationLine.preferLineLock);
     					printf("[Clerk]AppClerk %d Get app line lock \n",clerkID);
     					if(applicationLine.preferLineCount != 0){
						//if there is customer in prefer line
       						printf("[Clerk]AppClerk %d check prefer line \n",clerkID);
         					applicationLine.preferLineCount --;
       						Signal(applicationLine.preferLineLock,applicationLine.preferLineCond); 
         					printf("[Clerk]AppClerk %d Release app line lock \n",clerkID);
         					Release(applicationLine.preferLineLock);
         					Yield();
      					}
					else{
         					Release(applicationLine.preferLineLock);
        					Acquire(applicationLine.regLineLock);

         					if(applicationLine.regLineCount != 0){
         						printf("[Clerk]AppClerk %d check reg line \n",clerkID);
            						applicationLine.regLineCount --;
            						Signal(applicationLine.regLineLock,applicationLine.regLineCond); 
            						Release(applicationLine.regLineLock);
            						Yield();
         					}
 						else{
           						Release(applicationLine.regLineLock);
            						//Go Sleep
           					 	printf("[Clerk]AppClerk %d leave table now",clerkID);
            						Acquire(applicationTable.tableLock);
           						applicationTable.clerkCount--;
            						Wait(applicationTable.tableLock,applicationTable.tableCond);
            						Release(applicationTable.tableLock);
            						printf("[Clerk]AppClerk %d now come back to table \n",clerkID);
         					}
      					} 
				}//while(1);

				Exit(0);
			  }

			- void pictureClerkRun(){
   				int clerkID = -1;
   				int c = 0;//customer
  				int type = 0;//Pic type = 0;
   				//Get Picture Clerk ID
   				Acquire(pictureClerkLock);
   				clerkID = pictureClerkIDCount ++;
   				Release(pictureClerkLock);
   
				printf("[Clerk]PicClerk %d Start Running \n",clerkID);
   				while(1){
      					//Do Lock
      					Acquire(pictureLine.preferLineLock);
     	 				printf("[Clerk]PicClerk %d Get Pic line lock \n",clerkID);
      					if(pictureLine.preferLineCount != 0){
						//if there is customer in prefer line
         					printf("[Clerk]PicClerk %d check prefer line \n",clerkID);
         					pictureLine.preferLineCount --;
         					Signal(pictureLine.preferLineLock,pictureLine.preferLineCond); 
         					printf("[Clerk]PicClerk %d Rel Pic line lock \n",clerkID);
         					Release(pictureLine.preferLineLock);
         					Yield();
      					}
					else{
         					Release(pictureLine.preferLineLock);
         					Acquire(pictureLine.regLineLock);

        					if(pictureLine.regLineCount != 0){
            						printf("[Clerk]PicClerk %d check reg line \n",clerkID);
            						pictureLine.regLineCount --;
           						Signal(pictureLine.regLineLock,pictureLine.regLineCond); 
            						Release(pictureLine.regLineLock);
            						Yield();
         					}
						else {
           						Release(pictureLine.regLineLock);
            						//Go Sleep
           				 		printf("[Clerk]PicClerk %d leave table now\n",clerkID);//Must have
            						Acquire(pictureTable.tableLock);
            						//printf("[Clerk]PicTableClerk [%d]",pictureTable.clerkCount);
            						pictureTable.clerkCount--;
            						Wait(pictureTable.tableLock,pictureTable.tableCond);
            						Release(pictureTable.tableLock);
            						//printf("[Clerk]PicClerk %d now come back\n",clerkID);
         					}
      					} 
				}//while(1);
				Exit(0);
			  }

			- void passportClerkRun(){
   				int clerkID = -1;
   				int c = 0;//customer
   				int type = 0;//Passport type = 0;
   				//Get Passportture Clerk ID
   				Acquire(passportClerkLock);
   				clerkID = passportClerkIDCount ++;
   				Release(passportClerkLock);
   
				printf("[Clerk]PaClerk %d Start Running \n",clerkID);
   				while(1){
      					//Do Lock
      					Acquire(passportLine.preferLineLock);
     	 				printf("[Clerk]PaClerk %d Get line lock \n",clerkID);
      					if(passportLine.preferLineCount != 0){
						//if there is customer in prefer line
         					printf("[Clerk]PaClerk %d check prefer line \n",clerkID);
         					passportLine.preferLineCount --;
         					Signal(passportLine.preferLineLock,passportLine.preferLineCond); 
         					printf("[Clerk]PastClerk %d Release line lock \n",clerkID);
         					Release(passportLine.preferLineLock);
         					Yield();
      					}
					else{
        				 	Release(passportLine.preferLineLock);
         					Acquire(passportLine.regLineLock);

         					if(passportLine.regLineCount != 0){
           						printf("[Clerk]PassportClerk %d check reg line \n",clerkID);
           			 			passportLine.regLineCount --;
            						Signal(passportLine.regLineLock,passportLine.regLineCond); 
           	 					Release(passportLine.regLineLock);
            						Yield();
         					}
						else {
           						Release(passportLine.regLineLock);
            						//Go Sleep
            						printf("[Clerk]PatClerk %d leave now \n",clerkID);
            						Acquire(passportTable.tableLock);
           						passportTable.clerkCount--;
            						Wait(passportTable.tableLock,passportTable.tableCond);
            						Release(passportTable.tableLock);
            						printf("[Clerk]PaClerk %d now come back \n",clerkID);
         					}
      					} 
				}//while(1);
				Exit(0);
			  }

			- void cashierClerkRun(){
   				int clerkID = -1;
   				int c = 0;//customer
   				int type = 0;//cashier type = 0;
   				//Get cashier Clerk ID
   				Acquire(cashierClerkLock);
   				clerkID = cashierClerkIDCount ++;
   				Release(cashierClerkLock);
   
				printf("[Clerk]cashierClerk %d Start Running \n",clerkID);
   			while(1){
      				//Do Lock
      				Acquire(cashierLine.preferLineLock);
      				printf("[Clerk]cClerk %d Get cashier line lock\n",clerkID);
      				if(cashierLine.preferLineCount != 0){ 
					//if there is customer in prefer line
         				printf("[Clerk]cClerk %d check prefer line\n",clerkID);
        		 		cashierLine.preferLineCount --;
         				Signal(cashierLine.preferLineLock,cashierLine.preferLineCond); 
        	 			printf("[Clerk]cClerk %d Release cashier line lock\n",clerkID);
         				Release(cashierLine.preferLineLock);
         				Yield();
      				}
				else{
        				Release(cashierLine.preferLineLock);
         				Acquire(cashierLine.regLineLock);

         				if(cashierLine.regLineCount != 0){
           					printf("[Clerk]cashierClerk %d check reg line \n",clerkID);
            					cashierLine.regLineCount --;
            					Signal(cashierLine.regLineLock,cashierLine.regLineCond); 
            					Release(cashierLine.regLineLock);
            					Yield();
         				}
					else {
           			 		Release(cashierLine.regLineLock);
            					//Go Sleep
           					printf("[Clerk]caClerk %d leave now\n",clerkID);
            					Acquire(cashierTable.tableLock);
            					cashierTable.clerkCount--;
            					Wait(cashierTable.tableLock,cashierTable.tableCond);
            					Release(cashierTable.tableLock);
            					printf("[Clerk]caClerk %d now come \n",clerkID);
         				}
      				} 
			}//while(1);
			Exit(0);
		  }

		- void managerRun(){
      			while(totalFinishCustomer != NUM_OF_CUSTOMER){
     				printf("[Manager] %d total finish customer \n",totalFinishCustomer);
         			Acquire(applicationTable.tableLock);
            			//Keep this print
            			printf("[Manager] app table clerk count %d \n",applicationTable.clerkCount);
                  		if(applicationTable.clerkCount == 0){
            				applicationTable.clerkCount++;
            				//printf("[Manager] wake one app clerk up \n");
            				Signal(applicationTable.tableLock,applicationTable.tableCond);
         			} 
         			Release(applicationTable.tableLock);
         			Acquire(pictureTable.tableLock);
         			if(pictureTable.clerkCount == 0){
           				pictureTable.clerkCount++;
            				//printf("[Manager] wake one pic clerk up \n ");
            				Signal(pictureTable.tableLock,pictureTable.tableCond);
         			} 
         			Release(pictureTable.tableLock);
        			Acquire(passportTable.tableLock);
            			//printf("[Manager] passport table clerk count %d \n",passportTable.clerkCount);
                		if(passportTable.clerkCount == 0){
            				passportTable.clerkCount++;
            				//printf("[Manager] wake one passport clerk up \n ");
            				Signal(passportTable.tableLock,passportTable.tableCond);
         			} 
         			Release(passportTable.tableLock);
         			Acquire(cashierTable.tableLock);
            			//printf("[Manager] cashier table clerk count %d \n",cashierTable.clerkCount);
                  		if(cashierTable.clerkCount == 0){
            				cashierTable.clerkCount++;
            				//printf("[Manager] wake one cashier clerk up \n ");
            				Signal(cashierTable.tableLock,cashierTable.tableCond);
         			} 
         			Release(cashierTable.tableLock);
      				Yield();
   			}
  			Exit(0);
		  }

		- void Office(){
			int i;
	
			/*  Create all required lock and condition for table, and line for passport office*/
	
			totalFinishCustomerLock = CreateLock();
	
			applicationTable.tableLock = CreateLock();
			pictureTable.tableLock = CreateLock();
			passportTable.tableLock = CreateLock();
			cashierTable.tableLock = CreateLock();

			customerIDLock = CreateLock();
			applicationClerkLock = CreateLock();
			pictureClerkLock = CreateLock();
			passportClerkLock = CreateLock();
			cashierClerkLock = CreateLock();
		
			applicationTable.tableCond = CreateCondition();
			pictureTable.tableCond = CreateCondition();
			passportTable.tableCond = CreateCondition();
			cashierTable.tableCond = CreateCondition();
			
			applicationLine.regLineLock = CreateLock();
			applicationLine.preferLineLock = CreateLock();
			applicationLine.regLineCond = CreateCondition();
			applicationLine.preferLineCond = CreateCondition();
	
			pictureLine.regLineLock = CreateLock();
			pictureLine.preferLineLock = CreateLock();
			pictureLine.regLineCond = CreateCondition();
			pictureLine.preferLineCond = CreateCondition();
	
			passportLine.regLineLock = CreateLock();
			passportLine.preferLineLock = CreateLock();
			passportLine.regLineCond = CreateCondition();
			passportLine.preferLineCond = CreateCondition();
	
			cashierLine.regLineLock = CreateLock();
			cashierLine.preferLineLock = CreateLock();
			cashierLine.regLineCond = CreateCondition();
			cashierLine.preferLineCond = CreateCondition();
	   
			pplicationTable.clerkCount = 0;
   			pictureTable.clerkCount = 0;
   			passportTable.clerkCount = 0;
   			cashierTable.clerkCount = 0;
   
			/*Initialize values for the four lines, clean them up*/
			for(i=0; i<NUM_OF_CUSTOMER; i++){
				applicationLine.regLine[i].ID = -1;
				applicationLine.regLine[i].status = 0;
				applicationLine.preferLine[i].ID = -1;
				applicationLine.preferLine[i].status = 0;
			}
			for(i=0; i<NUM_OF_CUSTOMER; i++){
				pictureLine.regLine[i].ID = -1;
				pictureLine.regLine[i].status = 0;
				pictureLine.preferLine[i].ID = -1;
				pictureLine.preferLine[i].status = 0;
			}
			for(i=0; i<NUM_OF_CUSTOMER; i++){
				passportLine.regLine[i].ID = -1;
				passportLine.regLine[i].status = 0;
				passportLine.preferLine[i].ID = -1;
				passportLine.preferLine[i].status = 0;
			}
			for(i=0; i<NUM_OF_CUSTOMER; i++){
				cashierLine.regLine[i].ID = -1;
				cashierLine.regLine[i].status = 0;
				cashierLine.preferLine[i].ID = -1;
				cashierLine.preferLine[i].status = 0;
			}
	
			/*Creating Customers*/
			for(i=0; i<NUM_OF_CUSTOMER; i++){
				customerArray[i].money = 1600;
				customerArray[i].applicationDone = 0;
				customerArray[i].pictureDone = 0;
				customerArray[i].passportDone = 0;
				customerArray[i].cashierDone = 0;
				Fork(customerRun);
			}
	
			/* Creating Clerks for application table*/
			for(i=0; i<NUM_OF_CLERK; i++){
				applicationClerkArray[i].responsibleTable = 0;
      				applicationTable.clerkCount++;
				Fork(applicationClerkRun);
			}
	
			/* Creating Clerks for picture table*/
			for(i=0; i<NUM_OF_CLERK; i++){
				pictureClerkArray[i].responsibleTable = 1;
     	 			pictureTable.clerkCount ++;
				Fork(pictureClerkRun);
			}
	
			/* Creating Clerks for passport table*/
			for(i=0; i<NUM_OF_CLERK; i++){
				passportClerkArray[i].responsibleTable = 2;
      				passportTable.clerkCount ++;
				Fork(passportClerkRun);
			}
	
			/* Creating Clerks for cashier table*/
			for(i=0; i<NUM_OF_CLERK; i++){
				cashierClerkArray[i].responsibleTable = 3;
      				cashierTable.clerkCount ++;
				Fork(cashierClerkRun);
			}
	
			/*Create Manager*/
			Fork(managerRun);
		  }

		- void finalization(){
			/* Destroy all created lock and condition */
			DestroyLock(applicationLine.preferLineLock);
			DestroyLock(applicationLine.regLineLock);
			DestroyLock(pictureLine.preferLineLock);
			DestroyLock(pictureLine.regLineLock);
			DestroyLock(passportLine.preferLineLock);
			DestroyLock(passportLine.regLineLock);
			DestroyLock(cashierLine.preferLineLock);
			DestroyLock(cashierLine.regLineLock);
 
			DestroyLock(applicationTable.tableLock);
			DestroyLock(pictureTable.tableLock);
			DestroyLock(passportTable.tableLock);
			DestroyLock(cashierTable.tableLock);
		
			DestroyCondition(applicationTable.tableCond);
			DestroyCondition(pictureTable.tableCond);
			DestroyCondition(passportTable.tableCond);
			DestroyCondition(cashierTable.tableCond);
		  }

		- void handleCustomer(int c,int type){
   			// Type 0 : Application Clerk
   			// Type 1 : Picture Clerk
   			// Type 2 : Clerk
   			// Type 3 : Application Clerk
   			switch(type){
   				case 0:
      					customerArray[c].applicationDone = 1;
     					break;
   				case 1:
      					customerArray[c].pictureDone= 1;
      					break;
   				case 2:
      					customerArray[c].passportDone= 1;
      					break;
  				 case 3:
      					customerArray[c].cashierDone= 1;
      					break;
      			}
		  }

		- int getCustomerID(int l,int PreOrReg){
   			// PreOrReg 0 : prefer line 
   			// PreOrReg 1 : regular line
  			cLine *line = (cLine*)l;
  	 		int i;
   			int customerID = -1;
  			for(i = 0 ; i < NUM_OF_CUSTOMER ; i++){
   				if(PreOrReg == 0){
      					//check prefer line
     					if(line->preferLine[i].status == 1){
      						//get id than set spot to empty
     					 	customerID = line->preferLine[i].ID;
      						line->preferLine[i].status = 0;
      						line->preferLineCount --;
      						break;
     					} 
   				}
				else{
      					//check regular line
     					if(line->regLine[i].status == 1){
      						//get id than set spot to empty
      						customerID = line->regLine[i].ID;
      						line->regLine[i].status = 0;
      						line->regLineCount --;
      						break;
     					} 
   				}//end PreOrReg
  
  			}//end for 
  			return customerID;
		  } 


	+ Functions modified and in which file.
		- None.

***************
* V. Testing: *
***************
================================================= PART 1 & PART 2 ==================================================
	+ How to test
		- Input "gmake" under /code/ directory for compile from command prompt.
		- Input "make" under code/test directory, make sure you can run the cpp2c.pl perl script 
		- Go to code/test directory when running testfile (to ensure the path of filename used by exec syscall)
		- Input "../userprog/nachos -x lockcond" under /code/test/ directory to display the behavior of all lock, condition, fork and exit Syscall.
		- Input "../userprog/nachos -x test_fork" under /code/test/ directory to display the behavior of fork syscall.
		- Input "../userprog/nachos -x test_exec" under /code/test/ directory to display the behavior of Exec syscall.

	+ Test output
		- Lock and Condition Syscalls. (test_lockcond.c)
			- Main starts in the beginning and starts the test.
			- Assign Lock 1's id to 0 and Lock 2's id to 1.
			- Main starts the test and create all Locks and Conditions.
			- Function 1 forked by Main and Main waits on condition 1 with Lock 1.
			- Function 1 starts and signals on conditional 1 with Lock 1.
			- Function 1 waits on Conditional 2 with Lock 2.
			- Main releasing Lock 1 and acquiring Lock 1 again.
			- Main prepares to forked Function 2, and waits from Function 2.
			- Function 2 starts and signals on Conditional 2 with Lock 1.
			- Function 2 waits on Conditional 3 with Lock 2.
			- Main wakes up on Condition 2 with Lock 1 and released Lock 1.
			- Main broadcasts on Condition 2 with Lock 2 after released Lock 1.
			- Main, Function 1, and Function 2 exit.
			- Finally, machine halted.

		- Fork Function. (test_fork.c)
			- Main starts in the beginning and function 1 and function 2 are forked by the main.
			- Function 1 starts and exits after Main exits.
 			- Function 2 starts and exits after Function 1 exits.
			- Finally, Machine halted.
			
		- Exec Function. (test_exec.c)
			- Main starts in the beginning and calls Exec Syscall twice.
			- Main execute the fork test file twice.
		
====================================================== PART 3 ======================================================
	+ How to test
		- Input "gmake" under /code/ directory for compile from command prompt.
		- Input "make" under code/test directory, make sure you can run the cpp2c.pl perl script 
		- Input "../userprog/nachos -x project2_final" under /code/test/ directory to simulate one office.
		- Input "../userprog/nachos -x multi_office" under /code/test/ directory from command prompt, this display the entire multiple office behavior.
		

	+ Test output
		- Both sigle office and multiple office works!!
		
*******************
* VI. Discussion: *
*******************
====================================================== PART 1 ======================================================
	+ Experiment expectation.  (What you hope will happen.)
		- Lock Syscalls, Condition Syscalls, Exit Syscall, Yield Syscall, and Process Table should be able to function correctly.
		- Demonstrate system calls work does not crash Nachos when used incorrectly.

	+ Experiment result.  (What actually happens.)
		- Functioned perfectly.
		- The result of this program meets the requirements.

	+ Explanation
		- The basic techniques were told by professor, simply modified into program's specification.

====================================================== PART 2 ======================================================
	+ Experiment expectation.  (What you hope will happen.)
		- Be able to Keep track of allocating physical memory frames using a bitmap.
		- Copying data to/from the kernel from/to the user's virtual address space.

	+ Experiment result.  (What actually happens.)
		- The result of this program meets the requirements.

	+ Explanation
		- With carefully reviewed the AddrSpace constructor and file handling system calls, the goal of our program achieved.

====================================================== PART 3 ======================================================
	+ Experiment expectation.  (What you hope will happen.)
		- Project2_final runs a single passport office with multiple customer and clerk threads.
 		- On further approach, we try to run multiple Passport Office (multi_office) independently and executing by different processes simultaneously.
		- Implement as a set of multithreaded Nachos user program with the Fork system call to create all threads in the program.

	+ Experiment result.  (What actually happens.)
		- Running single passport office meets the expected behavior or simulation.
		- Running multiple passport office meets the expected behavior of simulation.
		- The output log present several unnecessary "ne" "ln" ... comment in the log file, this is due
        to buggy string function(printf) we have implemented ourselves.
		- To cleanup the log, simply add "| grep CUST" to monitor costomer behavior, replace CUST with any other variable to monitor specific behavior.

	+ Explanation
		- With careful manipulation of the Fork system call to create all threads in the system, the program run as expected.

***********************
* VII. Miscellaneous: *
***********************
====================================================== PART 1 ======================================================
	- None.

====================================================== PART 2 ======================================================
	- None.

====================================================== PART 3 ======================================================
	- We implement our own // <-> /**/ comment convert tool for nachos test program. 
	   - cpp2c.pl will delete all the C++ style single line // comment when doing the make
	   - c2cpp.pl will convert all the C style /* */comment to C++ style // comment 
	   - In the code/test/Makefile, it will call cpp2c.pl to output tmp.c file which don't have
        //comment 
	- We implement our own string.h library for nachos userprogram. 
      - itsStrlen : compute the string length,same as strlen
      - itsStrcpy : copy string ,same as strcpy
      - itoa      : convert number to string by base number
      - vsprintf  : take the string patten then output string,current support %d,%c,%x
      - printf    : same as C lib printf, but only support %d,%c,%x
      - sprintf   : same as C lib sprintf, but only support %d,%c,%x
